<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modal analysis of a free-floating steel circle · FinEtoolsFlexBeamsTutorials.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FinEtoolsFlexBeamsTutorials.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="tutorials.html">Tutorials</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="circle_modal_tut.html">Modal analysis of a free-floating steel circle</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="circle_modal_tut.html">Modal analysis of a free-floating steel circle</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/FinEtoolsFlexBeamsTutorials.jl/blob/master/docs/src/tutorials/circle_modal_tut.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Modal-analysis-of-a-free-floating-steel-circle"><a class="docs-heading-anchor" href="#Modal-analysis-of-a-free-floating-steel-circle">Modal analysis of a free-floating steel circle</a><a id="Modal-analysis-of-a-free-floating-steel-circle-1"></a><a class="docs-heading-anchor-permalink" href="#Modal-analysis-of-a-free-floating-steel-circle" title="Permalink"></a></h1><h2 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h2><p>Vibration analysis of a beam simply supported in one plane, and clamped in another. The results are compared with analytical expressions. This is a benchmark from the NAFEMS Selected Benchmarks for Natural Frequency Analysis, publication: Test VM09: Circular Ring –  In-plane and Out-of-plane Vibration.</p><h2 id="Reference-frequencies"><a class="docs-heading-anchor" href="#Reference-frequencies">Reference frequencies</a><a id="Reference-frequencies-1"></a><a class="docs-heading-anchor-permalink" href="#Reference-frequencies" title="Permalink"></a></h2><p>There will be 6 rigid body modes (zero natural frequencies).</p><p>The numerical results are due to the publication: NAFEMS Finite Element Methods &amp; Standards, Abbassian, F., Dawswell, D. J., and Knowles, N. C. Selected Benchmarks for Natural Frequency Analysis, Test No.</p><ol><li>Glasgow: NAFEMS, Nov., 1987.</li></ol><p>The reference values were analytically determined (Blevins, FORMULAS FOR DYNAMICS, ACOUSTICS AND VIBRATION, Table 4.16). Note that shear flexibility was neglected when computing the reference values.</p><p>| Mode       |         Reference Value (Hz)  |  NAFEMS Target Value (Hz) |  | –––-   |     –––-  |  –––- |  | 7, 8 | (out of plane)   |        51.85          |         52.29  |  | 9, 10 |  (in plane)       |       53.38         |          53.97  |  | 11, 12 |  (out of plane)   |     148.8          |         149.7  |  | 13, 14 |  (in plane)       |     151.0          |         152.4  |  | 15, 16 |  (out of plane)   |     287.0          |         288.3  |  |  17, 18 |  (in plane)      |      289.5         |          288.3  |</p><h2 id="Goals"><a class="docs-heading-anchor" href="#Goals">Goals</a><a id="Goals-1"></a><a class="docs-heading-anchor-permalink" href="#Goals" title="Permalink"></a></h2><ul><li>Show convergence relative to reference values.</li><li>Demonstrate the optimization of eigenvalue accuracy by choosing mass type.</li></ul><pre><code class="language-julia">#</code></pre><h2 id="Definition-of-the-basic-inputs"><a class="docs-heading-anchor" href="#Definition-of-the-basic-inputs">Definition of the basic inputs</a><a id="Definition-of-the-basic-inputs-1"></a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-basic-inputs" title="Permalink"></a></h2><p>The finite element code realize on the basic functionality implemented in this package.</p><pre><code class="language-julia">using FinEtools</code></pre><p>The material parameters may be defined with the specification of the units. The elastic properties are:</p><pre><code class="language-julia">E = 200.0 * phun(&quot;GPa&quot;)
nu = 0.3;</code></pre><p>The mass density is</p><pre><code class="language-julia">rho = 8000 * phun(&quot;kg/m^3&quot;)</code></pre><p>Here are the cross-sectional dimensions and the length of the beam between supports.</p><pre><code class="language-julia">radius = 1.0 * phun(&quot;m&quot;); diameter = 0.1 * phun(&quot;m&quot;);

#</code></pre><h2 id="Cross-section"><a class="docs-heading-anchor" href="#Cross-section">Cross-section</a><a id="Cross-section-1"></a><a class="docs-heading-anchor-permalink" href="#Cross-section" title="Permalink"></a></h2><p>Cross-sectional properties are incorporated in the cross-section property. The three arguments supplied are functions. All are returning &quot;constants&quot;. In particular the first two functions each return the dimension of the cross-section as a constant(the beam has a uniform cross-section); the third function defines the orientation of the cross-section in the global Cartesian coordinates. <code>[1.0, 0.0, 0.0]</code> is the vector that together with the tangent to the midline curve of the beam spans the <span>$x_1x_2$</span> plane of the local coordinates for the beam.</p><pre><code class="language-julia">using FinEtoolsFlexBeams.CrossSectionModule: CrossSectionCircle
cs = CrossSectionCircle(s -&gt; diameter/2, s -&gt; [1.0, 0.0, 0.0])
@show cs.parameters(0.0)</code></pre><p>For instance the the first out of plane mode is listed in the reference cited above as</p><pre><code class="language-julia">R = radius
I = cs.parameters(0.0)[4]
m = rho * cs.parameters(0.0)[1]
J = cs.parameters(0.0)[2]
G = E/2/(1+nu)
i = 2 # the first non-rigid body mode
@show i*(i^2-1)/(2*pi*R^2)*sqrt(E*I/m/(i^2+E*I/G/J))</code></pre><p>The first &quot;ovaling&quot; (in-plane) mode is:</p><pre><code class="language-julia">i = 2 # the first ovaling mode
@show i*(i^2-1)/(2*pi*R^2*(i^2+1)^(1/2))*sqrt(E*I/m)</code></pre><p>The purpose of the numerical model is to calculate approximation to the reference frequencies.</p><pre><code class="language-julia">neigvs = 18;</code></pre><p>We will generate</p><pre><code class="language-julia">n = 20</code></pre><p>beam elements along the member.</p><pre><code class="language-julia">using FinEtoolsFlexBeams.MeshFrameMemberModule: frame_member
tolerance = radius/n/1000;
fens, fes = frame_member([0 0 0; 2*pi 0 0], n, cs)
for i in 1:count(fens)
    a = fens.xyz[i, 1]
    fens.xyz[i, :] .= (radius+radius*cos(a), radius*sin(a), 0)
end
fens, fes = mergenodes(fens, fes, tolerance, [1, n+1])

#</code></pre><h2 id="Material"><a class="docs-heading-anchor" href="#Material">Material</a><a id="Material-1"></a><a class="docs-heading-anchor-permalink" href="#Material" title="Permalink"></a></h2><p>Material properties can be now used to create a material: isotropic elasticity model of the <code>FinEtoolsDeforLinear</code> package is instantiated.</p><pre><code class="language-julia">using FinEtoolsDeforLinear
material = MatDeforElastIso(DeforModelRed3D, rho, E, nu, 0.0)

#</code></pre><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><p>Now we start constructing the discrete finite element model. We begin by constructing the requisite fields, geometry and displacement. These are the so-called &quot;configuration variables&quot;, all initialized to 0. This is that geometry field.</p><pre><code class="language-julia">geom0 = NodalField(fens.xyz)</code></pre><p>This is the displacement field, three unknown displacements per node.</p><pre><code class="language-julia">u0 = NodalField(zeros(size(fens.xyz, 1), 3))</code></pre><p>This is the rotation field, three unknown rotations per node are represented with a rotation matrix, in total nine numbers. The utility function <code>initial_Rfield</code></p><pre><code class="language-julia">using FinEtoolsFlexBeams.RotUtilModule: initial_Rfield
Rfield0 = initial_Rfield(fens)</code></pre><p>Here we verify the number of nodes and the number of degrees of freedom in the rotation field per node.</p><pre><code class="language-julia">@show nents(Rfield0)
@show ndofs(Rfield0)</code></pre><p>Finally, this is the displacement and rotation field for incremental changes, incremental displacements and incremental rotations. In total, 6 unknowns per node.</p><pre><code class="language-julia">dchi = NodalField(zeros(size(fens.xyz, 1), 6))</code></pre><p>There are no support conditions.</p><pre><code class="language-julia">applyebc!(dchi)</code></pre><p>The  the number of free (unknown) degrees of freedom is equal to the total number of degrees of freedom in the system.</p><pre><code class="language-julia">numberdofs!(dchi);


#</code></pre><h2 id="Assemble-the-global-discrete-system"><a class="docs-heading-anchor" href="#Assemble-the-global-discrete-system">Assemble the global discrete system</a><a id="Assemble-the-global-discrete-system-1"></a><a class="docs-heading-anchor-permalink" href="#Assemble-the-global-discrete-system" title="Permalink"></a></h2><pre><code class="language-julia">using FinEtoolsFlexBeams.FEMMCorotBeamModule: FEMMCorotBeam
femm = FEMMCorotBeam(IntegDomain(fes, GaussRule(1, 2)), material);</code></pre><p>For disambiguation we will refer to the stiffness and mass functions by qualifying them with the corotational-beam module, <code>FEMMCorotBeamModule</code>.</p><pre><code class="language-julia">using FinEtoolsFlexBeams.FEMMCorotBeamModule
CB = FEMMCorotBeamModule</code></pre><p>Thus we can construct the stiffness and mass matrix as follows: Note that the finite element machine is the first argument. This provides access to the integration domain. The next argument is the geometry field, followed by the displacement, rotations, and incremental displacement/rotation fields.</p><pre><code class="language-julia">K = CB.stiffness(femm, geom0, u0, Rfield0, dchi);
M = CB.mass(femm, geom0, u0, Rfield0, dchi);</code></pre><p>We can compare the size of the stiffness matrix with the number of degrees of freedom that are unknown (20).</p><pre><code class="language-julia">@show size(K)

#</code></pre><h2 id="Solve-the-free-vibration-problem"><a class="docs-heading-anchor" href="#Solve-the-free-vibration-problem">Solve the free-vibration problem</a><a id="Solve-the-free-vibration-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-free-vibration-problem" title="Permalink"></a></h2><pre><code class="language-julia">oshift = (2*pi*15)^2</code></pre><p>The Arnoldi algorithm implemented in the well-known <code>Arpack</code> package is used to solve the generalized eigenvalue problem with the sparse matrices. As is common in structural dynamics, we request the smallest eigenvalues in absolute value (<code>:SM</code>).</p><pre><code class="language-julia">using Arpack
evals, evecs, nconv = eigs(K + oshift * M, M; nev=neigvs, which=:SM);</code></pre><p>First  we should check that the requested eigenvalues actually converged:</p><pre><code class="language-julia">@show nconv == neigvs</code></pre><p>The eigenvalues (i. e. the squares of the angular frequencies) are returned in the vector <code>evals</code>. The mode shapes constitute the columns of the matrix <code>evecs</code>.</p><pre><code class="language-julia">@show size(evecs)</code></pre><p>The natural frequencies are obtained from the squares of the angular frequencies. We note the use of <code>sqrt.</code> which broadcast the square root over the array <code>evals</code>.</p><pre><code class="language-julia">fs = sqrt.([max(0, e - oshift) for e in evals]) / (2 * pi);

#</code></pre><h2 id="Comparison-of-computed-and-analytical-results"><a class="docs-heading-anchor" href="#Comparison-of-computed-and-analytical-results">Comparison of computed and analytical results</a><a id="Comparison-of-computed-and-analytical-results-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-of-computed-and-analytical-results" title="Permalink"></a></h2><p>The approximate and analytical frequencies are now reported.</p><pre><code class="language-julia">sigdig(n) = round(n * 10000) / 10000
println(&quot;Approximate frequencies: $(sigdig.(fs)) [Hz]&quot;)

#</code></pre><h2 id="Set-up-the-visualization-of-the-vibration-modes"><a class="docs-heading-anchor" href="#Set-up-the-visualization-of-the-vibration-modes">Set up the visualization of the vibration modes</a><a id="Set-up-the-visualization-of-the-vibration-modes-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-visualization-of-the-vibration-modes" title="Permalink"></a></h2><p>The animation will show one of the vibration modes overlaid on the undeformed geometry. The configuration during the animation needs to reflect rotations. The function <code>update_rotation_field!</code> will update the rotation field given a vibration mode.</p><pre><code class="language-julia">using FinEtoolsFlexBeams.RotUtilModule: update_rotation_field!</code></pre><p>The visualization utilities take advantage of the PlotlyJS library.</p><pre><code class="language-julia">using PlotlyJS
using FinEtoolsFlexBeams.VisUtilModule: plot_space_box, plot_solid, render, react!, default_layout_3d, save_to_json</code></pre><p>The magnitude of the vibration modes (displacements  and rotations) will be amplified with this scale factor:</p><pre><code class="language-julia">scale = 1.5</code></pre><p>In order to handle variables inside loops correctly, we create a local scope with the <code>let end</code> block.</p><pre><code class="language-julia">vis(mode) = let</code></pre><p>The extents of the box will be preserved during animation in order to eliminate changes in the viewing parameters.</p><pre><code class="language-julia">    tbox = plot_space_box(reshape(inflatebox!(boundingbox(fens.xyz), 0.3 * radius), 2, 3))</code></pre><p>This is the geometry of the structure without deformation (undeformed). It is displayed as gray, partially transparent.</p><pre><code class="language-julia">    tenv0 = plot_solid(fens, fes; x=geom0.values, u=0.0 .* dchi.values[:, 1:3], R=Rfield0.values, facecolor=&quot;rgb(125, 155, 125)&quot;, opacity=0.3);</code></pre><p>Initially the plot consists of the box and the undeformed geometry.</p><pre><code class="language-julia">    plots = cat(tbox, tenv0; dims=1)</code></pre><p>Create the layout for the plot. Set the size of the window.</p><pre><code class="language-julia">    layout = default_layout_3d(;width=600, height=600)</code></pre><p>Set the aspect mode to get the correct proportions.</p><pre><code class="language-julia">    layout[:scene][:aspectmode] = &quot;data&quot;</code></pre><p>Render the undeformed structure</p><pre><code class="language-julia">    pl = render(plots; layout=layout, title=&quot;Mode $(mode)&quot;)
    sleep(2.115)</code></pre><p>This is the animation loop.</p><ol><li>Distribute a fraction of the selected eigenvector into the incremental displacement/rotation field.</li><li>Create the deformed configuration by defining displacement field <code>u1</code> and rotation field <code>Rfield1</code>.</li><li>Create the plot for the deformed configuration, and add it to the list of plots.</li><li>Call the <code>react!</code> function to update the display. Sleep for a brief period of time to give the display a chance to become current.</li></ol><pre><code class="language-julia">    for xscale in scale .* sin.(collect(0:1:89) .* (2 * pi / 21))
        scattersysvec!(dchi, xscale .* evecs[:, mode])
        u1 = deepcopy(u0)
        u1.values .= dchi.values[:, 1:3]
        Rfield1 = deepcopy(Rfield0)
        update_rotation_field!(Rfield1, dchi)
        tenv1 = plot_solid(fens, fes; x=geom0.values, u=dchi.values[:, 1:3], R=Rfield1.values, facecolor=&quot;rgb(50, 55, 125)&quot;);
        plots = cat(tbox, tenv0, tenv1; dims=1)
        react!(pl, plots, pl.plot.layout)
        sleep(0.115)
    end
end

#</code></pre><h2 id="Visualize-vibration-mode"><a class="docs-heading-anchor" href="#Visualize-vibration-mode">Visualize vibration mode</a><a id="Visualize-vibration-mode-1"></a><a class="docs-heading-anchor-permalink" href="#Visualize-vibration-mode" title="Permalink"></a></h2><p>Animate the harmonic motion of the mode given as argument: vis(7)</p><pre><code class="language-julia">using FinEtoolsFlexBeams.FESetCorotBeamModule: MASS_TYPE_CONSISTENT_NO_ROTATION_INERTIA,
MASS_TYPE_CONSISTENT_WITH_ROTATION_INERTIA,
MASS_TYPE_LUMPED_DIAGONAL_NO_ROTATION_INERTIA,
MASS_TYPE_LUMPED_DIAGONAL_WITH_ROTATION_INERTIA

results = let
    results = Dict()
    for mtype in [
        MASS_TYPE_CONSISTENT_NO_ROTATION_INERTIA,
        MASS_TYPE_CONSISTENT_WITH_ROTATION_INERTIA,
        MASS_TYPE_LUMPED_DIAGONAL_NO_ROTATION_INERTIA,
        MASS_TYPE_LUMPED_DIAGONAL_WITH_ROTATION_INERTIA]
        M = CB.mass(femm, geom0, u0, Rfield0, dchi; mass_type = mtype);
        evals, evecs, nconv = eigs(K + oshift * M, M; nev=neigvs, which=:SM);
        results[mtype] = evals, evecs
    end
    results
end

colors = [
&quot;rgb(125, 15, 15)&quot;,
&quot;rgb(15, 155, 15)&quot;,
&quot;rgb(15, 15, 155)&quot;,
&quot;rgb(125, 115, 115)&quot;
]

evals = results[MASS_TYPE_CONSISTENT_NO_ROTATION_INERTIA][1]
x = 1:length(evals); y = sqrt.([max(0, e - oshift) for e in evals]) / (2 * pi);
tc0 = scatter(;x=x, y=y, mode=&quot;markers&quot;, name = &quot;cons, wo&quot;, line_color = &quot;rgb(215, 15, 15)&quot;, marker = attr(size = 9, symbol = &quot;diamond-open&quot;))
evals = results[MASS_TYPE_CONSISTENT_WITH_ROTATION_INERTIA][1]
x = 1:length(evals); y = sqrt.([max(0, e - oshift) for e in evals]) / (2 * pi);
tc1 = scatter(;x=x, y=y, mode=&quot;markers&quot;, name = &quot;cons, w&quot;, line_color = &quot;rgb(15, 215, 15)&quot;, marker = attr(size = 9, symbol = &quot;triangle-down&quot;))
evals = results[MASS_TYPE_LUMPED_DIAGONAL_NO_ROTATION_INERTIA][1]
x = 1:length(evals); y = sqrt.([max(0, e - oshift) for e in evals]) / (2 * pi);
tc2 = scatter(;x=x, y=y, mode=&quot;markers&quot;, name = &quot;lumped, wo&quot;, line_color = &quot;rgb(15, 15, 215)&quot;, marker = attr(size = 9, symbol = &quot;x-open&quot;))
evals = results[MASS_TYPE_LUMPED_DIAGONAL_WITH_ROTATION_INERTIA][1]
x = 1:length(evals); y = sqrt.([max(0, e - oshift) for e in evals]) / (2 * pi);
tc3 = scatter(;x=x, y=y, mode=&quot;markers&quot;, name = &quot;lumped, w&quot;, line_color = &quot;rgb(165, 165, 15)&quot;, marker = attr(size = 9, symbol = &quot;square&quot;))</code></pre><p>7, 8 (out of plane)         51.85                 52.29 9, 10 (in plane)            53.38                 53.97 11, 12 (out of plane)      148.8                 149.7 13, 14 (in plane)          151.0                 152.4 15, 16 (out of plane)      287.0                 288.3 17, 18 (in plane)          289.5                 288.3</p><pre><code class="language-julia">rfs = vec(Float64[0 0 0 0 0 0 51.85 51.85 53.38 53.38 148.8 148.8 151.0 151.0 287.0 287.0 289.5 289.5])

rtc = scatter(;x=collect(1:length(rfs)), y=rfs, mode=&quot;lines&quot;, name = &quot;ref&quot;, line_color = &quot;rgb(15, 15, 15)&quot;)</code></pre><p>Set up the layout:</p><pre><code class="language-julia">layout = Layout(;width=650, height=400, xaxis=attr(title=&quot;Mode&quot;, type = &quot;linear&quot;), yaxis=attr(title=&quot;Frequency [hertz]&quot;, type = &quot;linear&quot;), title = &quot;Comparison of mass types&quot;)</code></pre><p>Plot the graphs:</p><pre><code class="language-julia">pl = plot([rtc, tc0, tc1, tc2, tc3], layout; options = Dict(
        :showSendToCloud=&gt;true,
        :plotlyServerURL=&gt;&quot;https://chart-studio.plotly.com&quot;
        ))
display(pl)


#</code></pre><h2 id="&quot;Mixed&quot;-mass-matrix"><a class="docs-heading-anchor" href="#&quot;Mixed&quot;-mass-matrix">&quot;Mixed&quot; mass matrix</a><a id="&quot;Mixed&quot;-mass-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;Mixed&quot;-mass-matrix" title="Permalink"></a></h2><p>As the graph suggests we can try mixing together mass matrices computed from different assumptions (lumped versus consistent, with or without rotation inertia). No particular justification can be provided for these numbers other than best low-frequency matching for linear bars suggests that 50% can be taken lumped and 50% consistent. Here it is obviously more complicated due to the presence of rotation inertia.</p><pre><code class="language-julia">M = 0.5 .* CB.mass(femm, geom0, u0, Rfield0, dchi; mass_type = MASS_TYPE_LUMPED_DIAGONAL_NO_ROTATION_INERTIA) +
    0.5 .* CB.mass(femm, geom0, u0, Rfield0, dchi; mass_type = MASS_TYPE_CONSISTENT_WITH_ROTATION_INERTIA);</code></pre><p>With this mixed mass matrix we solve the free vibration problem again.</p><pre><code class="language-julia">evals, evecs, nconv = eigs(K + oshift * M, M; nev=neigvs, which=:SM);</code></pre><p>Plotting the newly obtained data on top of the previously presented data, we can observe sometimes substantial improvement of accuracy of the mixed-matrix formulation relative to the individual mass matrix types.</p><pre><code class="language-julia">x = 1:length(evals); y = sqrt.([max(0, e - oshift) for e in evals]) / (2 * pi);
mtc = scatter(;x=x, y=y, mode=&quot;markers&quot;, name = &quot;mixed&quot;, line_color = &quot;rgb(215, 15, 215)&quot;, marker = attr(size = 9, symbol = &quot;circle&quot;))
pl = plot([rtc, tc0, tc1, tc2, tc3, mtc], layout; options = Dict(
        :showSendToCloud=&gt;true,
        :plotlyServerURL=&gt;&quot;https://chart-studio.plotly.com&quot;
        ))
display(pl)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 26 August 2020 22:22">Wednesday 26 August 2020</span>. Using Julia version 1.5.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
